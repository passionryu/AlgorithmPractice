Q1: DFS의 시간 복잡도는?
A: O(V + E).
설명: 각 정점은 한 번 방문, 각 간선은 두 번(무방향) 또는 한 번(유향) 검사.

Q2: DFS로 최단 경로를 항상 구할 수 있는가?
A: 아니다(일반 그래프에서 X).
설명: DFS는 깊이를 우선하므로 가장 빨리 발견된 경로가 최단이 아닐 수 있음. (무가중치 최단경로는 BFS)

Q3: 재귀 DFS와 스택(반복) DFS의 차이?
A: 동작 원리는 동일 — 재귀는 시스템 스택 사용, 반복은 명시적 Stack 사용. 재귀는 간단하나 깊이 깊으면 스택오버플로 위험.

Q4: DFS로 사이클을 어떻게 검출하나(무방향)?
A: 인접 노드를 방문했는데 visited이고 그 노드가 parent가 아니라면 사이클.
설명: 부모만 예외로 두면 간선 교차로 인한 방문은 사이클.

Q5: DFS로 사이클 검출(유향) 방법?
A: visited 와 recStack(현재 재귀 호출 스택)에 둘 다 사용. recStack[next] == true 이면 back edge → 사이클.

Q6: 연결 컴포넌트 개수는 어떻게 구하나?
A: 모든 정점에 대해 if not visited → DFS 실행 → 실행한 횟수가 컴포넌트 수.

Q7: DFS에서 엣지가 back edge이면 무엇을 의미하나?
A: 조상 노드로 향하는 간선 — 사이클 존재의 증거(유향).

Q8: DFS 재귀에서 visited 체크를 언제 하는 것이 좋은가? (push 전에 vs pop 후)
A: 보통 노드를 스택에 넣기 전에(또는 재귀 진입 초기에) visited=true로 둠. (중복 push 방지)

Q9: 트리(루트 1, children 2,3; 2 children 4,5)에 대해 DFS preorder는?
A: 1 2 4 5 3.

Q10: 위 트리의 postorder는?
A: 4 5 2 3 1.

Q11: 위상 정렬은 DFS로 가능한가? 요약하라.
A: 가능. DFS 후 완료(피니시) 시간이 큰 순으로 정점을 나열(스택에 넣고 역순 출력).

Q12: DFS의 최대 재귀 깊이는?
A: 최악 O(V). (선형 연결일 때) → 스택오버플로 유의.

Q13: 인접 행렬과 인접 리스트의 DFS 차이(시간 관점)?
A: 인접 행렬: O(V^2). 인접 리스트: O(V + E). 희소 그래프는 리스트 우수.

Q14: low 값을 이용하면 무엇을 구할 수 있나?
A: 브리지(간선이 끊어질 때)와 절단점(정점 제거시 컴포넌트 증가)을 구함 (Tarjan 계열).

Q15: DFS로 모든 경로를 탐색하려면 어떻게 해야하나?
A: 재귀에서 도착 조건마다 해(경로)를 기록하고 계속 백트래킹 하며 다른 선택지 탐색.

Q16: DFS에서 간선이 두 번 검사되는 이유는?
A: 무방향 그래프에선 간선을 v->u와 u->v 두 방향에서 각각 검사하기 때문(하지만 visited로 재진입 제어).

Q17: DFS가 BFS보다 유리한 문제 유형?
A: 해의 깊이가 중요하거나 백트래킹으로 모든 해를 찾는 문제(퍼즐, 조합).

Q18: 방향 그래프에서 visitTime과 finishTime을 기록하면 무엇에 쓰이나?
A: 엣지 분류, 위상정렬(완료시간 역순), SCC/브리지 판별 등의 기초 자료.

Q19: DFS 탐색 순서를 결정하는 요소는?
A: 인접 리스트 내 정점 나열 순서(오름차순/내림차순)에 의해 탐색 순서가 달라짐.

Q20: DFS로 미로(2D)에서 길이 있는지 판별하는 기본 아이디어는?
A: 시작점에서 상하좌우로 재귀(또는 스택)으로 이동하며 방문표시, 목적지 도달 시 true 반환하고 재귀로 전파.